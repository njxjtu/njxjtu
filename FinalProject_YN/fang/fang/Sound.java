package fang;import java.io.IOException;import java.net.URL;import java.util.HashSet;import java.util.LinkedList;import javax.sound.midi.MidiSystem;import javax.sound.midi.Sequence;import javax.sound.midi.Sequencer;import javax.sound.sampled.AudioFormat;import javax.sound.sampled.AudioInputStream;import javax.sound.sampled.AudioSystem;import javax.sound.sampled.Clip;import javax.sound.sampled.FloatControl;import javax.sound.sampled.LineUnavailableException;import javax.sound.sampled.Mixer;import javax.sound.sampled.UnsupportedAudioFileException;import javax.swing.JFileChooser;import static fang.ErrorConsole.*;/**This class handles playing, * pausing, and muting sounds. * Only the following formats * are supported: wav, aiff, * au, mid, rmf. * @author Jam Jenkins */public class Sound{    /**the sounds not currently at the end position of the track*/    private static HashSet<Playable> currentlyPlaying =        new HashSet<Playable>();    /**the sounds which should go back to the beginning     * after reaching the end*/    private static HashSet<Playable> looping=new HashSet<Playable>();    /**the sound clips cached (both playing and done playing)*/    private LinkedList<Playable> sounds;    /**the location of the sound file*/    private URL soundFile;        /**the loaded sound data*/    private byte[] soundData;        /**the format of the sound*/    private AudioFormat soundFormat;    /**determines if the currently playing sounds should advance*/    private static boolean paused=true;    /**determines if the advancing of sounds should be audible*/    private static long muted=System.currentTimeMillis();    /**the sound to loop through when there is an error*/    private static final URL ERROR=        Sound.class.getResource("resources/error.wav");        /**the ideal mixer to use*/    private Mixer.Info mixerInfo;        /**the horizontal location of the sound*/    private float pan=0;        /**Makes a sound clip.  The clip can be played repeatedly     * and does not need to finish before playing again.     * Supported formats are wav, aiff, au, mid, rmf.     * Since the entire clip must be loaded into memory,     * avoid playing very large sound files.  An audio     * error clip will be played if there is an error.     * @param soundFile the url of the sound clip     */    private void initialize(URL soundFile)    {        this.soundFile = soundFile;        sounds = new LinkedList<Playable>();        if(isSampled())            loadSampledData();        Playable clip = getPlayable();        if (clip != null)            sounds.add(clip);        else        {            System.err.println("URL: " + soundFile +                     " not valid sound file.");            this.soundFile=ERROR;            loadSampledData();            clip = getPlayable();            sounds.add(clip);            loop();        }    }        /**Makes a sound clip.  The clip can be played repeatedly     * and does not need to finish before playing again.     * Supported formats are wav, aiff, au, mid, rmf.     * Since the entire clip must be loaded into memory,     * avoid playing very large sound files.  An audio     * error clip will be played if there is an error.     * @param filename the relative filename of the sound clip     */    public Sound(String filename)    {        initialize(getResource(filename));    }        /**     * Used internally to create a sound     * @param url the url for the given filename     */    private Sound(URL url)    {        initialize(url);    }        /**gets the URL from the relative filename     * @param filename the relative filename     * @return the url corresponding to the filename     */    public URL getResource(String filename)    {        StackTraceElement[] all=Thread.currentThread().getStackTrace();        int i;        for(i=0; i<all.length; i++)            if(all[i].getClassName().equals(getClass().getCanonicalName()))                break;        i++;        while(all[i].getClassName().equals(getClass().getCanonicalName()))            i++;        try        {            Class c=Class.forName(all[i].getClassName());            URL url=c.getResource(filename);            if(url==null)            {                String packageName=c.getPackage().getName();            	String folderName=            		packageName.replaceAll("\\.", "/")+"/"+            		filename.substring(0, Math.max(0, filename.lastIndexOf("/")));            	String file=filename.substring(filename.lastIndexOf("/")+1);            	String diagnosis=            		            		"The resource "+fixedWidth(file)+" is not found.";            	String fix=            		"Make sure the file<br>"+            		indent(fixedWidth(file))+            		" is in the folder<br>"+            		indent(fixedWidth(folderName))+            		"<br>Check for spelling and case sensitivity errors."+            		" For example, if the file is " +            		fixedWidth("sound.wav") +            		" and you reference the file as " +            		fixedWidth("sound.WAV") +            		", then it would not work because " +            		fixedWidth("wav") +" and "+            		fixedWidth("WAV") +            		" are different case.";            	ErrorConsole.addError(diagnosis, fix, new NullPointerException());            }            return url;        } catch (ClassNotFoundException e)        {            e.printStackTrace();            return null;        }    }        /**plays the clip in a continuous loop.     * Call stopLooping to prevent the sound     * from looping again and stop to immediately     * stop the playing sound.     */    public void loop()    {        play(true);    }        /**plays the sound either once or     * repeatedly     * @param repeat if true, then the     * sound will loop, otherwise it will     * only play until the end.     */    private void play(boolean repeat)    {    	removeFinishedSounds();        if (sounds.isEmpty())            return;        if(soundFile==ERROR && !sounds.getFirst().clipIsDone())            return;        //recycle clips if possible        Playable available = null;        for (Playable clip : sounds)        {            if (clip.clipIsDone())            {                available = clip;                break;            }        }        if (available == null)        {            available = getPlayable();        }        else        {            sounds.remove(available);        }        available.setMicrosecondPosition(0);        sounds.addLast(available);        currentlyPlaying.add(available);        if(repeat)        {            looping.add(available);            available.loop();        }        if (muted < 0 && !paused)        {            available.start();        }        else if (!paused)        {            long currentTime = System.currentTimeMillis();            advanceSounds(currentTime - muted);            muted = currentTime;        }    }        /**gets the midi Playable     * @return the clip to play, or null     * if the soundFile cannot be loaded.      */    private Playable getMidiPlayable()    {        try        {            Sequencer sequencer=MidiSystem.getSequencer();            Sequence sequence=MidiSystem.getSequence(soundFile);            sequencer.setSequence(sequence);            sequencer.open();            return new Playable(sequencer);        }        catch(Exception e)        {        	String filename=soundFile.getFile();        	int lastSeparator=filename.lastIndexOf('/');        	String shortFile=filename.substring(lastSeparator+1);        	String diagnosis="You are trying to use a midi sound, but" +        			" unfortunately this format is not entirely supported.";        	String fix="Please use only "+fixedWidth("wav")+" format audio files. "+			"Try opening "+fixedWidth(shortFile)+			" in Audacity or another sound "+    		"editing software and export the sound in wav format as "+    		fixedWidth(shortFile.substring(0, shortFile.indexOf('.'))+".wav")+    		", then change all references from "+    		fixedWidth(shortFile)+" to "+    		fixedWidth(shortFile.substring(0, shortFile.indexOf('.'))+".wav.");        	ErrorConsole.addError(diagnosis, fix, e);        	return null;        }    }      private void addError(javax.sound.sampled.UnsupportedAudioFileException e)    {    	String filename=soundFile.getFile();    	int lastSeparator=filename.lastIndexOf('/');    	String shortFile=filename.substring(lastSeparator+1);    	String diagnosis=null;    	String fix=null;    	if(filename.toLowerCase().endsWith("wav"))    	{    		diagnosis=        		"Wav files are supported, but not all sample rates."+        		subHeading("Suggested Fixes");       		fix=        		"Try opening "+        		fixedWidth(shortFile)+" using Audacity " +        		"or another sound "+        		"editing software and export in wav format using a "+        		"different sample rate.";    	}    	else if(filename.indexOf('.')>=0)    	{    		diagnosis=    			"You tried to load the sound "+fixedWidth(shortFile)+", "+    			"but unfortunately the FANG Engine does not support "+    			fixedWidth(filename.substring(filename.lastIndexOf('.')+1))+    			" format.";    		fix="Please use only "+fixedWidth("wav")+" format audio files. "+    			"Try opening "+fixedWidth(shortFile)+    			" in Audacity or another sound "+        		"editing software and export the sound in wav format as "+        		fixedWidth(shortFile.substring(0, shortFile.indexOf('.'))+".wav")+        		", then change all references from "+        		fixedWidth(shortFile)+" to "+        		fixedWidth(shortFile.substring(0, shortFile.indexOf('.'))+".wav.");    	}    	else    	{    		diagnosis=    			"Sorry, only "+fixedWidth("wav")+" files are supported.";    		fix=    			"Try opening "+fixedWidth(shortFile)+    			" in Audacity or another sound "+        		"editing software and export in wav format.";        			    	}    	ErrorConsole.addError(diagnosis, fix, e);        e.printStackTrace();    }        /**loads the entire clip into memory for     * non-midi sound clips.  This is necessary     * because the sound clip may overflow the     * default buffer when relying on the simpler     * manner of getting at the data.     */    private void loadSampledData()    {        try        {            AudioInputStream inputStream=AudioSystem.getAudioInputStream(soundFile);            int bytesPerFrame=inputStream.getFormat().getFrameSize();            if(bytesPerFrame<0) return;            soundData=new byte[(int)inputStream.getFrameLength()*bytesPerFrame];            soundFormat=inputStream.getFormat();            int read=inputStream.read(soundData);            while(read<soundData.length)            {                int bytesRead=inputStream.read(soundData, read, soundData.length-read);                if(bytesRead<=0)                {                    System.err.println("problems reading audio file");                    break;                }                read+=bytesRead;            }            inputStream.close();        }        catch(javax.sound.sampled.UnsupportedAudioFileException e)        {        	addError(e);        } catch (IOException e)		{        	addUnknownError(e);        	e.printStackTrace();		}            }            /**stops all currently playing      * and looping clips     */    public void stop()    {        for(Playable clip: sounds)        {        	clip.stop();            clip.setMicrosecondPosition(clip.getMicrosecondLength() - 1);            looping.remove(clip);        }    }      /**prevents this clip from going     * back to the beginning when it     * completes playing     */    public void stopLooping()    {        for(Playable clip: sounds)        {            looping.remove(clip);            clip.stop();            clip.start();        }            }    /**determines if the filename contains     * the extension .mid or .rmf     * @return true if the filename contains     * the extension .mid or .rmf, false      * otherwise.  If the file does not      * exist, this also returns false.     */    public boolean isMidi()    {        try        {            return soundFile.getFile().toLowerCase().indexOf(".mid")>=0 ||                soundFile.getFile().toLowerCase().indexOf(".rmf")>=0;        }        catch(NullPointerException npe)        {            return false;        }    }        /**determines if the filename is something     * other than a midi.     * @return true is this clip is not a midi,     * false otherwise.  This method returns     * true if the sound file does not exist.     */    public boolean isSampled()    {        return !isMidi();    }        /**gets the mp3 playable.  This method     * requires a non-standard plugin, so mp3's     * are not directly supported.  If the     * plugin is installed, then this method     * will correctly load the mp3.     * @return the generic Playable object     */    private Playable getMP3Playable()    {        try        {            AudioInputStream in= AudioSystem.getAudioInputStream(soundFile);            AudioInputStream din = null;            AudioFormat baseFormat = in.getFormat();            AudioFormat decodedFormat =                new AudioFormat(AudioFormat.Encoding.PCM_SIGNED,                                baseFormat.getSampleRate(),                                16,                                baseFormat.getChannels(),                                baseFormat.getChannels() * 2,                                baseFormat.getSampleRate(),                                false);            din = AudioSystem.getAudioInputStream(decodedFormat, in);            Clip clip;            clip = AudioSystem.getClip();            clip.open(din);            clip.setMicrosecondPosition(clip.getMicrosecondLength());            return new Playable(clip);        }        catch(Exception e)        {            e.printStackTrace();            return null;        }    }        /**gets the mixer that has pan control*/    private void findRightMixer()    {    	Mixer.Info[] mix=AudioSystem.getMixerInfo();    	int i;    	for(i=0; i<mix.length; i++)    	{    		Clip clip;    		System.out.println("getting sampled 1: num mixers: "+AudioSystem.getMixerInfo().length);    		try			{				clip = AudioSystem.getClip(mix[i]);	    		clip.open(soundFormat, soundData, 0, soundData.length);	    		clip.getControl(FloatControl.Type.PAN);	    		break;			} catch (Exception e)			{			}    	}    	if(i>=mix.length)    		i=0;   		mixerInfo=mix[i];    }            /**sets the horizontal pan     * @param x zero indicates entirely on the      * left and one indicates entirely on the right.     * Values in between indicate balances between     * the left and right speaker.     */    public void setSoundPosition(double x)    {    	pan=(float)Math.min(1, Math.max(x*2-1, -1));    	for(Playable play: sounds)    	{	    		setSoundPan(play);    	}    }        /**     * sets the pan of the sound if panning is supported     * @param play the sound to pan     */    private void setSoundPan(Playable play)    {		if(play.sampled!=null && play.sampled.isOpen())		{			try			{				((FloatControl) play.sampled.getControl(FloatControl.Type.PAN)).setValue(pan);			}			catch(Exception e){}		}    	    }        /**uses the loaded data to create the     * Playable sound clip     * @return the sampled sound clip     */    private Playable getSampledPlayable()    {        if(soundData==null)            return null;        try        {            Clip clip;            if(mixerInfo==null) findRightMixer();            clip = AudioSystem.getClip(mixerInfo);            clip.open(soundFormat, soundData, 0, soundData.length);            clip.setMicrosecondPosition(                    clip.getMicrosecondLength());            Playable play=new Playable(clip);            setSoundPan(play);            return play;        } catch (LineUnavailableException e)        {            try            {                Playable p=getMP3Playable();                if(p!=null) return p;                Clip clip;                clip = AudioSystem.getClip();                AudioInputStream inputStream=AudioSystem.getAudioInputStream(soundFile);                clip.open(inputStream);                clip.setMicrosecondPosition(clip.getMicrosecondLength());                return new Playable(clip);            }            catch(LineUnavailableException ef)            {            	String filename=soundFile.getFile();            	int lastSeparator=filename.lastIndexOf('/');            	String shortFile=filename.substring(lastSeparator+1);            	String diagnosis="The sound file " +            		fixedWidth(shortFile)+" is too big.  The FANG " +            				"Engine can only plan uncompressed audio in " +            				"wav format.";            	String fix="Unfortunately, there is not an easy fix." +            			" You could try downsampling your audio file" +            			" in order to reduce its size using a sound" +            			" editing tool such as Audacity.";            	ErrorConsole.addError(diagnosis, fix, ef);                ef.printStackTrace();                return null;            }            catch(IOException ioe)            {            	addUnknownError(ioe);                ioe.printStackTrace();                return null;                            }            catch(UnsupportedAudioFileException afe)            {            	addError(afe);            	return null;            }        }               }        /**makes a new sound clip positioned      * at the end of the track     * @return the newly created sound clip     */    private Playable getPlayable()    {        if(isMidi())            return getMidiPlayable();        return getSampledPlayable();    }    /**     * plays the sound clip, getting it from the     * cache of finished playing clips, or     * makes a new clip if all cached clips are      * currently playing     */    public void play()    {        play(false);    }    private void removeFinishedSounds()    {        LinkedList<Playable> temp=new LinkedList<Playable>();        for(Playable clip: currentlyPlaying)            if(clip.clipIsDone())            {                if(!looping.contains(clip))                    temp.add(clip);            }        currentlyPlaying.removeAll(temp);    	    }        /**stops every sound     */    public static void clearAll()    {        for(Playable clip: currentlyPlaying)        {        	clip.stop();            clip.setMicrosecondPosition(clip.getMicrosecondLength() - 1);        }        currentlyPlaying.clear();    }        /**clears the cache of sounds except for those     * in the provided parameter     * @param excluded the persistent sounds     */    public static void clearAllExcept(Sound[] excluded)    {        HashSet<Playable> all=new HashSet<Playable>();        for(Sound sound: excluded)        {            all.addAll(sound.sounds);        }        for(Playable clip: currentlyPlaying)        {            if(!all.contains(clip))            {            	clip.stop();                clip.setMicrosecondPosition(clip.getMicrosecondLength() - 1);            }        }    }        /**     * stops the current playing of the tracks in     * the current location     */    public static void pause()    {        if (paused)            return;        paused = true;        if(muted>0)        	advanceSounds(System.currentTimeMillis()-muted);        Playable[] clips = currentlyPlaying.toArray(new Playable[0]);        for (Playable clip : clips)        {            clip.stop();        }    }    /**     * resumes playing the tracks      * from their current location     */    public static void resume()    {        if (muted > 0)            muted = System.currentTimeMillis();        if (!paused)            return;        paused = false;        if (muted >= 0)            return;        Playable[] clips = currentlyPlaying.toArray(new Playable[0]);        for (Playable clip : clips)        {            clip.start();        }    }    /**     * makes the advancing of tracks not audible     */    public static void mute()    {        if (muted > 0)            return;        muted = System.currentTimeMillis();        Playable[] clips = currentlyPlaying.toArray(new Playable[0]);        for (Playable clip : clips)        {            clip.stop();        }    }    /**     * advances the time of the track while muted     * @param millis the amount of time to advance in milliseconds     */    private static void advanceSounds(long millis)    {        LinkedList<Playable> toRemove = new LinkedList<Playable>();        Playable[] clips = currentlyPlaying.toArray(new Playable[0]);        for (Playable clip : clips)        {            long currentTime = clip.getMicrosecondPosition();            long endTime = clip.getMicrosecondLength() - 1;            long micros = millis * 1000;            if (endTime <= currentTime + micros)            {                if(looping.contains(clip))                {                    long changedMicros=micros;                    while(endTime <= currentTime + changedMicros)                        changedMicros-=clip.getMicrosecondLength();                    clip.setMicrosecondPosition(currentTime + changedMicros);                                    }                else                {                    toRemove.add(clip);                    clip.setMicrosecondPosition(clip.getMicrosecondLength() - 1);                }            }            else                clip.setMicrosecondPosition(currentTime + micros);        }        currentlyPlaying.removeAll(toRemove);    }    /**     * makes the advancement of tracks audible     */    public static void turnSoundOn()    {        if (muted > 0 && !paused)        {            advanceSounds(System.currentTimeMillis() - muted);        }        muted = -1;        if (paused)            return;        Playable[] clips = currentlyPlaying.toArray(new Playable[0]);        for (Playable clip : clips)        {            clip.start();        }    }    /**wraps the midi and sampled clips     * into one.  They both have the same     * methods, but do not implement the     * same interface, so this class wraps     * them to make them look the same.      * @author Jam Jenkins     */    static class Playable    {        /**the wav, au, or aiff sound clip*/        Clip sampled;        /**the midi or rmf sound clip*/        Sequencer midi;                /**initializes this Playable with         * a sampled clip         * @param clip the sampled clip         */        public Playable(Clip clip)        {            sampled=clip;        }                public void loop()        {            if(sampled!=null)                sampled.loop(Clip.LOOP_CONTINUOUSLY);            else                midi.setLoopCount(Sequencer.LOOP_CONTINUOUSLY);        }                /**initializes this Playable with         * a midi clip         * @param s the midi clip         */        public Playable(Sequencer s)        {            midi=s;        }                /**starts the clip playing*/        public void start()        {            if(sampled!=null)                sampled.start();            else                midi.start();        }                /**sets the position of this clip in         * microseconds         * @param micro the time in microseconds         */        public void setMicrosecondPosition(long micro)        {            if(sampled!=null)                sampled.setMicrosecondPosition(micro);            else                midi.setMicrosecondPosition(micro);                    }                /**gets the position of this clip in         * microseconds         * @return the time in microseconds         */        public long getMicrosecondPosition()        {            if(sampled!=null)                return sampled.getMicrosecondPosition();            return midi.getMicrosecondPosition();                                }                /**determines if this clip is within one         * millisecond of finishing         * @return true if the clip is finished         * playing, false otherwise         */        public boolean clipIsDone()        {            if(sampled!=null)            {                return sampled.getFramePosition()+1>=                    sampled.getFrameLength() ||                    (!sampled.isRunning() && sampled.getFramePosition()==0);            }            return midi.getMicrosecondPosition()+1000>=                midi.getMicrosecondLength() ||                (!midi.isRunning() && midi.getMicrosecondPosition()==0);        }        /**gets the duration of this clip in         * microseconds         * @return the duration in microseconds         */        public long getMicrosecondLength()        {            if(sampled!=null)                return sampled.getMicrosecondLength();            return midi.getMicrosecondLength();        }                /**stops playing the clip*/        public void stop()        {            if(sampled!=null)                sampled.stop();            else                midi.stop();        }                /**gets the sampled clip         * @return the sampled clip,         * or null if this Playable was         * constructed with a midi.         */        public Clip getClip()        {            return sampled;        }                /**gets the midi Sequencer         * @return the midi sequencer,         * or null if this Playable was         * constructed with a sampled         * clip.         */        public Sequencer getMidi()        {            return midi;        }    }            /**This method can be run to see if a Sound is     * in the correct format to play using the gaming     * engine.  If the sound plays when running this     * class, then it should be able to be played in     * a game created using the FANG Engine.  Likewise     * if the sound does not play, then the format     * is not such that the FANG Engine can play the     * sound.  In this case, change the format of the     * sound file into an acceptable format.     * @param argv not used     * @throws Exception     */    public static void main(String[] argv)        throws Exception    {        Sound.turnSoundOn();        Sound.resume();        JFileChooser chooser = new JFileChooser();        chooser.setFileSelectionMode(JFileChooser.FILES_ONLY);        chooser.setMultiSelectionEnabled(false);        int returnVal = chooser.showDialog(null, "Play Clip");        while(returnVal == JFileChooser.APPROVE_OPTION)         {           URL soundURL=chooser.getSelectedFile().toURL();           Sound sound=new Sound(soundURL);           sound.play();           returnVal = chooser.showDialog(null, "Play Clip");        }    }    /**removes all of the sounds from the cache*/    public static void cleanCache()    {        LinkedList<Playable> toRemove=new LinkedList<Playable>();        for(Playable play: currentlyPlaying)            if(play.clipIsDone())                toRemove.add(play);        currentlyPlaying.removeAll(toRemove);        toRemove.clear();        for(Playable play: looping)            if(play.clipIsDone())                toRemove.add(play);        looping.removeAll(toRemove);    }}